## Зауваження до оригінального коду

### Критичні проблеми

1. **Читання файлу як байтів без вказівки кодування**
   ```java
   new String(Files.readAllBytes(...))
→ Не враховує кодування (UTF-8?).
Рішення: new String(Files.readAllBytes(...), StandardCharsets.UTF_8).

2. **Оголошена функція cleanText(), але не використовується**
→ Код очищення тексту продубльовано в main.
Рішення: Видалити невикористану функцію або використовувати її.
3. **Неефективне видалення дублікатів через String.contains()**
   ```java 
   if (!distinctString.contains(words[i]))
→ Часова складність O(n²), бо contains шукає підрядок.
Рішення: Використовуй Set<String>.

4. **Подвійний підрахунок частоти слів вручну**
Спочатку збирає унікальні слова → потім рахує частоту → O(n²).
Рішення: Map<String, Long> + Collectors.groupingBy(..., counting()).
5. **Модифікація рядків у масиві під час сортування**
    ```java
    distincts[i] += " " + freq[i];
→ Потім сортує за числом всередині рядка → нестабільно, повільно.
Рішення: Зберігай слово і частоту окремо (Map.Entry).

6. **Сортування за регулярним виразом**
    ```java
    Integer.valueOf(str.replaceAll("[^0-9]", ""))
→ Дорого, може впати на порожньому рядку.
Рішення: Сортуй по long count напряму.

7. **Хардкод шляху до файлу**
→ Не гнучко, залежить від структури проєкту.
Рішення: Константа або аргумент командного рядка.

8. **Вивід останніх 30 елементів масиву**
    ```java
    distincts[distincts.length - 1 - i]
→ Працює, але неочевидно.
Рішення: Сортуй у зворотному порядку (reversed()).

9. **Відсутність обробки порожніх слів**
Після split(" +") можуть бути порожні рядки → зайві елементи.
Рішення: .filter(word -> !word.isEmpty()).

10. **Не використовується try-with-resources**
Хоча readAllBytes не потребує, але для кращої практики — використовуй.

11. **Відсутність констант**
Числа 30, шлях до файлу — хардкод.
Рішення: private static final.

12. **Не використовується Stream API**
Весь код можна замінити на 1-2 stream-вирази.
Рішення: Collectors.groupingBy, sorted, limit.

13. **Відсутність обробки винятків**
IOException просто пробраситься, але не обробляється.
Рішення: try-catch з інформативним повідомленням.

14. **Відсутність коментарів і структури**
Код монолітний, важко читати і підтримувати.

15. **Погано нормалізований текст**
Множинні пробіли → split(" +") → порожні елементи.
Рішення: .replaceAll("\\s+", " ").trim().
